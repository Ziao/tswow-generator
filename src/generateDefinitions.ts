import { ensureDir, remove, writeFile } from "fs-extra";
import documentationModules from "../temp/_documentationModules.json";
import { extractConstants } from "./lib/constants";
import { extractAllEnumNames, extractEnums } from "./lib/enums";
import { processFunction } from "./lib/functions";
import { wrapInNamespace } from "./lib/namespaces";
import { extractInterfaces } from "./lib/interfaces";
import { setEnums } from "./lib/types";
import { DocumentationModule } from "./types/documentationModule";
import prettier from "prettier";

(async () => {
    const typesBasePath = "./dist/types/generated";
    await remove(typesBasePath);
    await ensureDir(typesBasePath);

    // We extract all enum names across all modules.
    // Since enums live in an Enum namespace, and functions use them without a namespace, we need to rewrite their arguments to use the namespaced enum.
    const allEnumNames = extractAllEnumNames(documentationModules as DocumentationModule[]);
    setEnums(allEnumNames);

    for (const module of documentationModules as DocumentationModule[]) {
        // if (module.Name !== "CharacterCustomizationShared") continue;
        // if (module.Name !== "Unit") continue;
        // if (module.Name !== "Club") continue;

        console.log(`Processing ${module.Name ?? "Unnamed module"}..`);

        let contents = "// This file is automatically generated. Do not edit.\n\n";

        const enums = extractEnums(module.Tables, true);
        const enumsNameSpace = wrapInNamespace("Enum", enums.join("\n\n"));
        contents += enumsNameSpace + "\n\n";

        // Constants (these live in their own namespace, regardless of the module they're in)
        const constants = extractConstants(module.Tables);
        const constantsNameSpace = wrapInNamespace("Constants", constants.join("\n\n"), true);
        contents += constantsNameSpace + "\n\n";

        // Interfaces
        const interfaces = extractInterfaces(module.Tables);
        if (module.Namespace) contents += wrapInNamespace(module.Namespace, interfaces.join("\n\n"), true) + "\n\n";
        else contents += interfaces.join("\n\n") + "\n\n";

        // Functions
        if (module.Functions) {
            const functions = module.Functions.map((f) => processFunction(f, !module.Namespace));
            if (module.Namespace) contents += wrapInNamespace(module.Namespace, functions.join("\n\n"), true) + "\n\n";
            else contents += functions.join("\n\n") + "\n\n";
        }

        // Format types with prettier
        contents = await prettier.format(contents, { parser: "typescript", printWidth: 120, tabWidth: 4 });

        // We save these are .ts instead of .d.ts because of enums
        const path = `${typesBasePath}/${module.Name}.ts`;
        await writeFile(path, contents);
    }
})();
